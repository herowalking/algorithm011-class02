### 算法训练营Week04 (2020/07/13 ~ 2020/07/19)

#### DFS(深度优先搜索)
“不撞南墙不回头”，只要没有碰壁，就决不选择其它的道路，而是坚持向当前道路的深处挖掘——将“深度”作为前进的第一要素的搜索方法，就是所谓的“深度优先搜索”。深度优先搜索的核心思想，是试图穷举所有的完整路径。

深度优先搜索的本质——栈结构
深度优先搜索的过程可以转化为一系列的入栈、出栈操作。二叉树的先序遍历正是深度优先搜索思想的递归实现。可以说深度优先搜索过程就类似于树的先序遍历、是树的先序遍历的推广。
```
function preorder(root) {
  if (!root) return

  console.log(root.val)
  preorder(root.left)
  preorder(root.right)
}
```

在二叉树遍历的递归实现里，完全没有栈的影子——这东西似乎和栈没有什么直接联系啊，为啥咱们还说深度优先搜索的本质是栈呢？
我们从两个角度来理解这个事情：
- 首先，函数调用的底层，仍然是由栈来实现的。JS 会维护一个叫“函数调用栈”的东西，preorder每调用一次自己，相关调用的上下文就会被push进函数调用栈中；待函数执行完毕后，对应的上下文又会从调用栈中被pop出来。因此，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实。
- 其次，DFS 作为一种思想，它和树的递归遍历一脉相承、却并不能完全地画上等号——DFS 的解题场景其实有很多，其中有一类会要求我们记录每一层递归式里路径的状态，此时就会强依赖栈结构。

#### BFS(广度优先搜索)
与深度优先搜索不同的是，广度优先搜索（BFS）并不执着于“一往无前”这件事情。它关心的是眼下自己能够直接到达的所有坐标，其动作有点类似于“扫描”，或者可以想象成是水波纹的扩散。广度优先搜索每次以“广度”为第一要务、雨露均沾，一层一层地扫描，最后也能够将所有的坐标扫描完全。

在分层遍历的过程中，有两个规律：
- 每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。
- 站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。

丢弃已访问的坐标、记录新观察到的坐标，这个顺序毫无疑问符合了“先进先出”的原则，因此整个 BFS 算法的实现过程，和队列有着密不可分的关系。
在BSF过程里，我们循环往复地做了以下事情：
依次访问队列里已经有的坐标，将其出队；记录从当前坐标出发可直接抵达的所有坐标，将其入队。

以上逻辑用伪代码表述如下：
```
function BFS(入口坐标) {
  const queue = [] // 初始化队列queue
  // 入口坐标首先入队
  queue.push(入口坐标)
  // 队列不为空，说明没有遍历完全
  while (queue.length) {
    const top = queue[0] // 取出队头元素  

    访问 top // 此处是一些和 top 相关的逻辑，比如记录它对应的信息、检查它的属性等等

    // 注意这里也可以不用 for 循环，视题意而定
    for(检查 top 元素出发能够遍历到的所有元素)  {
      queue.push(top能够直接抵达的元素)
    }

    queue.shift() // 访问完毕。将队头元素出队
  }
}
```
注意，理论上来说只要我们拿到了 top，那么就不再关心队头元素了。因此这个 shift 出队的过程，其实是比较灵活的。一般只要我们拿到了 top，就可以执行 shift了。把top元素的访问和出队放在一起来做也是没问题的（除非题目中对出队的时机有强约束，但这种情况非常少见）。
```
const top = queue.shift()
```
BFS实战：二叉树的层序遍历
```
function BFS(root) {
  const queue = [] // 初始化队列queue
  // 根结点首先入队
  queue.push(root)
  // 队列不为空，说明没有遍历完全
  while (queue.length) {
    const top = queue[0] // 取出队头元素  
    // 访问 top
    console.log(top.val)
    // 如果左子树存在，左子树入队
    if (root.left) {
      queue.push(root.left)
    }
    // 如果左子树存在，右子树入队
    if (root.right) {
      queue.push(root.right)
    }
    queue.shift() // 访问完毕，队头元素出队
  }
}
```

#### 贪心算法（greedy algorithm）
贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是全局最好或最优的算法。 
贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。

贪心法可以解决一些最优化问题，如：求图中的最小生成树、求哈夫曼编码等。然而对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案。 
一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。

适用贪心算法的场景
简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解称为最优子结构。

贪心算法总是会选择当下的最优解，而不去考虑这一次的选择会不会对未来的选择造成影响。使用贪心算法通常表明，实现者希望做出的这一系列局部“最优”选择能够带来最终的整体“最优”选择。如果是这样的话，该算法将会产生一个最优解，否则，则会得到一个次优解。然而，对很多问题来说，寻找最优解很麻烦，这么做不值得，所以使用贪心算法就足够了。

#### 二分查找
二分查找法主要是解决在“一堆数中找出指定的数”这类问题。

而想要应用二分查找法，这“一堆数”必须有一下特征：（1）存储在数组中 （2） 有序排列
所以如果是用链表存储的，就无法在其上应用二分查找法了。

至于是顺序递增排列还是递减排列，数组中是否存在相同的元素都不要紧。不过一般情况，我们还是希望并假设数组是递增排列，数组中的元素互不相同。

二分查找法的js实现：
```
function bsearch(array, target) {
  let low = 0, high = array.length - 1;
  if (low > high) return -1;
  while (low <= high) {
    let mid = parseInt(low + (high - low) / 2);
    if (target === array[mid]) return mid;
    if (target > array[mid]) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return -1;
}
```



